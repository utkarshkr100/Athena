from typing import Dict, List, Any, Optional
from datetime import datetime
import json
import markdown
from .citation_manager import CitationManager, CitationStyle

class OutputFormatter:
    """Formats research reports in various output formats"""

    def __init__(self, citation_style: CitationStyle = CitationStyle.APA):
        self.citation_manager = CitationManager(citation_style)

    def format_as_markdown(
        self,
        report_data: Dict[str, Any],
        include_metadata: bool = True,
        include_toc: bool = True
    ) -> str:
        """Format report as Markdown"""
        markdown_parts = []

        # Title
        title = report_data.get('title', 'Research Report')
        markdown_parts.append(f"# {title}")
        markdown_parts.append("")

        # Metadata
        if include_metadata:
            metadata = report_data.get('metadata', {})
            markdown_parts.append("*Report Information*")
            markdown_parts.append(f"- **Generated on**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            if 'topic' in metadata:
                markdown_parts.append(f"- **Topic**: {metadata['topic']}")
            if 'report_style' in metadata:
                markdown_parts.append(f"- **Style**: {metadata['report_style']}")
            if 'total_sources' in metadata:
                markdown_parts.append(f"- **Sources**: {metadata['total_sources']}")
            markdown_parts.append("")

        # Executive Summary
        if 'executive_summary' in report_data and report_data['executive_summary']:
            markdown_parts.append("## Executive Summary")
            markdown_parts.append("")
            markdown_parts.append(report_data['executive_summary'])
            markdown_parts.append("")

        # Table of Contents
        if include_toc and 'sections' in report_data:
            markdown_parts.append("## Table of Contents")
            markdown_parts.append("")
            for i, section in enumerate(report_data['sections'], 1):
                section_title = section.get('title', f'Section {i}')
                anchor = section_title.lower().replace(' ', '-').replace('.', '').replace(',', '')
                markdown_parts.append(f"{i}. [{section_title}](#{anchor})")
            markdown_parts.append("")

        # Sections
        if 'sections' in report_data:
            for section in report_data['sections']:
                section_title = section.get('title', 'Untitled Section')
                section_content = section.get('content', '')

                markdown_parts.append(f"## {section_title}")
                markdown_parts.append("")

                # Process citations in content
                if 'citations' in section:
                    section_content = self._process_citations_in_content(
                        section_content,
                        section['citations']
                    )

                markdown_parts.append(section_content)
                markdown_parts.append("")

        # Bibliography
        if self.citation_manager.sources:
            markdown_parts.append("## References")
            markdown_parts.append("")
            bibliography = self.citation_manager.generate_bibliography()
            for entry in bibliography:
                markdown_parts.append(f"- {entry}")
            markdown_parts.append("")

        # Footer
        markdown_parts.append("---")
        markdown_parts.append("*Generated by Athena Multi-Agent Research System*")

        return "\n".join(markdown_parts)

    def format_as_html(
        self,
        report_data: Dict[str, Any],
        include_css: bool = True,
        custom_css: Optional[str] = None
    ) -> str:
        """Format report as HTML"""
        # First convert to markdown
        markdown_content = self.format_as_markdown(report_data)

        # Convert markdown to HTML
        html_content = markdown.markdown(
            markdown_content,
            extensions=['toc', 'tables', 'fenced_code', 'footnotes']
        )

        # Wrap in HTML structure
        html_document = self._create_html_wrapper(
            html_content,
            report_data.get('title', 'Research Report'),
            include_css,
            custom_css
        )

        return html_document

    def format_as_json(
        self,
        report_data: Dict[str, Any],
        include_citations: bool = True
    ) -> str:
        """Format report as structured JSON"""
        json_data = {
            "report": report_data,
            "generated_at": datetime.now().isoformat(),
            "format_version": "1.0"
        }

        if include_citations:
            json_data["citations"] = self.citation_manager.get_citation_summary()

        return json.dumps(json_data, indent=2, ensure_ascii=False)

    def format_as_latex(
        self,
        report_data: Dict[str, Any],
        document_class: str = "article"
    ) -> str:
        """Format report as LaTeX"""
        latex_parts = []

        # Document setup
        latex_parts.append(f"\\documentclass{{{document_class}}}")
        latex_parts.append("\\usepackage[utf8]{inputenc}")
        latex_parts.append("\\usepackage{hyperref}")
        latex_parts.append("\\usepackage{cite}")
        latex_parts.append("\\usepackage{graphicx}")
        latex_parts.append("")

        # Title and metadata
        title = report_data.get('title', 'Research Report')
        latex_parts.append(f"\\title{{{self._escape_latex(title)}}}")
        latex_parts.append("\\author{Athena Multi-Agent Research System}")
        latex_parts.append(f"\\date{{{datetime.now().strftime('%B %d, %Y')}}}")
        latex_parts.append("")

        # Begin document
        latex_parts.append("\\begin{document}")
        latex_parts.append("\\maketitle")
        latex_parts.append("")

        # Executive summary
        if 'executive_summary' in report_data and report_data['executive_summary']:
            latex_parts.append("\\section*{Executive Summary}")
            summary = self._escape_latex(report_data['executive_summary'])
            latex_parts.append(summary)
            latex_parts.append("")

        # Table of contents
        latex_parts.append("\\tableofcontents")
        latex_parts.append("\\newpage")
        latex_parts.append("")

        # Sections
        if 'sections' in report_data:
            for section in report_data['sections']:
                section_title = section.get('title', 'Untitled Section')
                section_content = section.get('content', '')

                latex_parts.append(f"\\section{{{self._escape_latex(section_title)}}}")

                # Process content
                content = self._escape_latex(section_content)
                latex_parts.append(content)
                latex_parts.append("")

        # Bibliography
        if self.citation_manager.sources:
            latex_parts.append("\\begin{thebibliography}{99}")
            bibliography = self.citation_manager.generate_bibliography()
            for i, entry in enumerate(bibliography, 1):
                entry_escaped = self._escape_latex(entry)
                latex_parts.append(f"\\bibitem{{ref{i}}} {entry_escaped}")
            latex_parts.append("\\end{thebibliography}")

        # End document
        latex_parts.append("\\end{document}")

        return "\n".join(latex_parts)

    def format_as_word_xml(self, report_data: Dict[str, Any]) -> str:
        """Format report as Word-compatible XML"""
        # Simplified Word XML format
        xml_parts = []

        xml_parts.append('<?xml version="1.0" encoding="UTF-8"?>')
        xml_parts.append('<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">')
        xml_parts.append('<w:body>')

        # Title
        title = report_data.get('title', 'Research Report')
        xml_parts.append(f'<w:p><w:pPr><w:pStyle w:val="Title"/></w:pPr><w:r><w:t>{self._escape_xml(title)}</w:t></w:r></w:p>')

        # Executive summary
        if 'executive_summary' in report_data:
            xml_parts.append('<w:p><w:pPr><w:pStyle w:val="Heading1"/></w:pPr><w:r><w:t>Executive Summary</w:t></w:r></w:p>')
            summary = self._escape_xml(report_data['executive_summary'])
            xml_parts.append(f'<w:p><w:r><w:t>{summary}</w:t></w:r></w:p>')

        # Sections
        if 'sections' in report_data:
            for section in report_data['sections']:
                section_title = section.get('title', 'Untitled Section')
                section_content = section.get('content', '')

                xml_parts.append(f'<w:p><w:pPr><w:pStyle w:val="Heading1"/></w:pPr><w:r><w:t>{self._escape_xml(section_title)}</w:t></w:r></w:p>')
                xml_parts.append(f'<w:p><w:r><w:t>{self._escape_xml(section_content)}</w:t></w:r></w:p>')

        xml_parts.append('</w:body>')
        xml_parts.append('</w:document>')

        return "\n".join(xml_parts)

    def export_citations_separate(
        self,
        format_type: str = "json"
    ) -> str:
        """Export citations as separate file"""
        return self.citation_manager.export_citations(format_type)

    def generate_report_package(
        self,
        report_data: Dict[str, Any],
        formats: List[str] = ["markdown", "html", "json"]
    ) -> Dict[str, str]:
        """Generate report in multiple formats"""
        package = {}

        for format_type in formats:
            if format_type == "markdown":
                package["report.md"] = self.format_as_markdown(report_data)
            elif format_type == "html":
                package["report.html"] = self.format_as_html(report_data)
            elif format_type == "json":
                package["report.json"] = self.format_as_json(report_data)
            elif format_type == "latex":
                package["report.tex"] = self.format_as_latex(report_data)
            elif format_type == "word":
                package["report.xml"] = self.format_as_word_xml(report_data)

        # Add citations file
        package["citations.json"] = self.export_citations_separate("json")
        package["bibliography.bib"] = self.export_citations_separate("bibtex")

        return package

    def _process_citations_in_content(
        self,
        content: str,
        citations: List[Dict[str, Any]]
    ) -> str:
        """Process citations within content"""
        # Add sources to citation manager
        for citation in citations:
            citation_id = self.citation_manager.add_source(
                title=citation.get('title', 'Unknown'),
                url=citation.get('url'),
                authors=citation.get('authors'),
                publication_date=citation.get('publication_date'),
                publisher=citation.get('publisher'),
                source_type=citation.get('source_type', 'web')
            )

            # Replace placeholder citations with formatted ones
            placeholder = f"[{citation.get('id', '')}]"
            if placeholder in content:
                formatted_citation = self.citation_manager.get_inline_citation(citation_id)
                content = content.replace(placeholder, formatted_citation)

        return content

    def _create_html_wrapper(
        self,
        content: str,
        title: str,
        include_css: bool,
        custom_css: Optional[str]
    ) -> str:
        """Create HTML document wrapper"""
        html_parts = [
            "<!DOCTYPE html>",
            "<html lang=\"en\">",
            "<head>",
            "<meta charset=\"UTF-8\">",
            "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">",
            f"<title>{self._escape_html(title)}</title>"
        ]

        if include_css:
            if custom_css:
                html_parts.append(f"<style>{custom_css}</style>")
            else:
                html_parts.append(self._get_default_css())

        html_parts.extend([
            "</head>",
            "<body>",
            "<div class=\"container\">",
            content,
            "</div>",
            "</body>",
            "</html>"
        ])

        return "\n".join(html_parts)

    def _get_default_css(self) -> str:
        """Get default CSS for HTML reports"""
        return """
        <style>
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
            margin-top: 2em;
            margin-bottom: 0.5em;
        }
        h1 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            border-bottom: 1px solid #bdc3c7;
            padding-bottom: 5px;
        }
        p {
            margin-bottom: 1em;
            text-align: justify;
        }
        ul, ol {
            margin-bottom: 1em;
            padding-left: 2em;
        }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 1em 0;
            padding-left: 1em;
            color: #7f8c8d;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .citation {
            color: #2980b9;
            font-weight: bold;
        }
        hr {
            border: none;
            border-top: 2px solid #ecf0f1;
            margin: 2em 0;
        }
        </style>
        """

    def _escape_html(self, text: str) -> str:
        """Escape HTML special characters"""
        if not text:
            return ""
        return (text.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&#x27;"))

    def _escape_latex(self, text: str) -> str:
        """Escape LaTeX special characters"""
        if not text:
            return ""
        latex_special = {
            '&': '\\&',
            '%': '\\%',
            '$': '\\$',
            '#': '\\#',
            '^': '\\textasciicircum{}',
            '_': '\\_',
            '{': '\\{',
            '}': '\\}',
            '~': '\\textasciitilde{}',
            '\\': '\\textbackslash{}'
        }

        for char, replacement in latex_special.items():
            text = text.replace(char, replacement)

        return text

    def _escape_xml(self, text: str) -> str:
        """Escape XML special characters"""
        if not text:
            return ""
        return (text.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&apos;"))